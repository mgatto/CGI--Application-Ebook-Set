<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>HTML::Template &ndash; Perl module to use HTML Templates from CGI scripts</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="css/modernperl.css" type="text/css" />
	</head>
	<body>
    	<div class="center">
			<h1>HTML::Template &mdash; 2.91</h1>
            <hr />
			<h3>Perl Module to use HTML Templates from CGI Scripts</h3>
		</div>

		<h2 id="synopsis">Synopsis</h2>
<p>First you make a template - this is just a normal HTML file with a few extra tags, the simplest being  <code>&lt;TMPL_VAR&gt;</code></p>
<p>For example, test.tmpl:</p>
<pre>
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;Test Template&lt;/title&gt;
    &lt;body&gt;
        My Home Directory is &lt;TMPL_VAR NAME=HOME&gt;
        &lt;p&gt;
        My Path is set to &lt;TMPL_VAR NAME=PATH&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Now create a small CGI program:</p>
<pre>
#!/usr/bin/perl -w
use HTML::Template;

# open the html template
my $template = HTML::Template-&gt;new(filename =&gt; 'test.tmpl');

# fill in some parameters
$template-&gt;param(HOME =&gt; $ENV{HOME});
$template-&gt;param(PATH =&gt; $ENV{PATH});
  
# send the obligatory Content-Type and print the template output
print &quot;Content-Type: text/html\n\n&quot;, $template-&gt;output;
</pre>
<p>If all is well in the universe this should show something like this in
your browser when visiting the CGI:</p>
<pre>
My Home Directory is /home/some/directory
My Path is set to /bin;/usr/bin
</pre>

<h2 id="description">Description</h2>
<p>This module attempts to make using HTML templates simple and natural. It extends standard HTML with a few new HTML-esque tags - <code>&lt;TMPL_VAR&gt;</code>, <code>&lt;TMPL_LOOP&gt;</code>, <code>&lt;TMPL_INCLUDE&gt;</code>, <code>&lt;TMPL_IF&gt;</code>, <code>&lt;TMPL_ELSE&gt;</code> and <code>&lt;TMPL_UNLESS&gt;</code>. The file written with HTML and these new tags is called a template. It is usually saved separate from your script - possibly even created by someone else!  Using this module you fill in the values for the variables, loops and branches declared in the template.  This allows you to separate design - the HTML - from the data, which you generate in the Perl script.</p>
<p>This module is licensed under the GPL.  See the LICENSE section below for more details.</p>

<h3>Tutorial</h3>
<p>If you're new to HTML::Template, I suggest you start with the introductory article available on the HTML::Template website: <a href="http://html-template.sourceforge.net">http://html-template.sourceforge.net</a>.</p>

<h3>Motivation</h3>
<p>It is true that there are a number of packages out there to do HTML templates.  On the one hand you have things like HTML::Embperl which allows you freely mix Perl with HTML.  On the other hand lie home-grown variable substitution solutions.  Hopefully the module can find a place between the two.</p>
<p>One advantage of this module over a full HTML::Embperl-esque solution is that it enforces an important divide - design and programming.  By limiting the programmer to just using simple variables and loops in the HTML, the template remains accessible to designers and other non-perl people.  The use of HTML-esque syntax goes further to make the format understandable to others.  In the future this similarity could be used to extend existing HTML editors/analyzers to support HTML::Template.</p>
<p>An advantage of this module over home-grown tag-replacement schemes is the support for loops.  In my work I am often called on to produce tables of data in html.  Producing them using simplistic HTML templates results in CGIs containing lots of HTML since the HTML itself cannot represent loops.  The introduction of loop statements in the HTML simplifies this situation considerably.  The designer can layout a single row and the programmer can fill it in as many times as necessary - all they must agree on is the parameter names.</p>
<p>For all that, I think the best thing about this module is that it does just one thing and it does it quickly and carefully.  It doesn't try to replace Perl and HTML, it just augments them to interact a little better.  And it's pretty fast.</p>

<h2 id="tags">The Tags</h2>

<h3>TMPL_VAR</h3>
<pre>
&lt;TMPL_VAR NAME=&quot;PARAMETER_NAME&quot;&gt;
</pre>
<p>The <code>&lt;TMPL_VAR&gt;</code> tag is very simple. For each <code>&lt;TMPL_VAR&gt;</code> tag in the template you call <code>$template-&gt;param(PARAMETER_NAME =&gt; &quot;VALUE&quot;)</code>.  When the template is output the <code>&lt;TMPL_VAR&gt;</code> is replaced with the VALUE text you specified.  If you don't set a parameter it just gets skipped in the output.</p>
<p>Optionally you can use the <code>ESCAPE=HTML</code> option in the tag to indicate that you want the value to be HTML-escaped before being returned from output (the old ESCAPE=1 syntax is still supported).  This means that the &quot;, &lt;, &gt;, and &amp; characters get translated into &amp;quot;, &amp;lt;, &amp;gt; and &amp;amp; respectively.  This is useful when you want to use a <code>TMPL_VAR</code> in a context where those characters would cause trouble. Example:</p>
<pre>
&lt;input name=param type=text value=&quot;&lt;TMPL_VAR NAME=&quot;PARAM&quot;&gt;&quot;&gt;
</pre>
<p>If you called <code>param()</code> with a value like sam&quot;my you'll get in trouble with HTML's idea of a double-quote.  On the other hand, if you use <code>ESCAPE=HTML</code>, like this:</p>
<pre>
&lt;input name=param type=text value=&quot;&lt;TMPL_VAR ESCAPE=HTML NAME=&quot;PARAM&quot;&gt;&quot;&gt;</pre>
<p>You'll get what you wanted no matter what value happens to be passed in for param.  You can also write <code>ESCAPE=&quot;HTML&quot;</code>, <code>ESCAPE='HTML'</code> and <code>ESCAPE='1'</code>.</p>
<p><code>ESCAPE=0</code> and <code>ESCAPE=NONE</code> turn off escaping, which is the default behavior.</p>
<p>There is also the <code>ESCAPE=URL</code> option which may be used for VARs that populate a URL.  It will do URL escaping, like replacing ' ' with '+' and '/' with '%2F'.</p>
<p>There is also the <code>ESCAPE=JS</code> option which may be used for VARs that
need to be placed within a Javascript string. All \n, \r, ' and &quot; characters
are escaped.</p>
<p>You can assign a default value to a variable with the DEFAULT attribute.  For example, this will output &quot;the devil gave me a taco&quot; if the &quot;who&quot; variable is not set.</p>
<pre>
The &lt;TMPL_VAR NAME=WHO DEFAULT=devil&gt; gave me a taco.
</pre>

<h3><code>TMPL_LOOP</code></h3>
<pre>
&lt;TMPL_LOOP NAME=&quot;LOOP_NAME&quot;&gt; &hellip; &lt;/TMPL_LOOP&gt;
</pre>
<p>The <code>&lt;TMPL_LOOP&gt;</code> tag is a bit more complicated than <code>&lt;TMPL_VAR&gt;</code>.  The <code>&lt;TMPL_LOOP&gt;</code> tag allows you to delimit a section of text and give it a name.  Inside this named loop you place <code>&lt;TMPL_VAR&gt;</code>s.  Now you pass to <code>param()</code> a list (an array ref) of parameter assignments (hash refs) for this loop.  The loop iterates over the list and produces output from the text block for each pass.  Unset parameters are skipped.  Here's an example:</p>
<p>In the template:</p>
<pre>
&lt;TMPL_LOOP NAME=EMPLOYEE_INFO&gt;
    Name: &lt;TMPL_VAR NAME=NAME&gt; &lt;br&gt;
    Job:  &lt;TMPL_VAR NAME=JOB&gt;  &lt;p&gt;
&lt;/TMPL_LOOP&gt;
</pre>
<p>In the script:</p>
<pre>
$template-&gt;param(EMPLOYEE_INFO =&gt; [ 
    { name =&gt; 'Sam', job =&gt; 'programmer' },
    { name =&gt; 'Steve', job =&gt; 'soda jerk' },
]
                         );
print $template-&gt;output();
</pre>
<p>The output in a browser:</p>
<pre>
Name: Sam
Job: programmer
	
Name: Steve
Job: soda jerk
</pre>
<p>As you can see above the <code>&lt;TMPL_LOOP&gt;</code> takes a list of variable assignments and then iterates over the loop body producing output.</p>
<p>Often you'll want to generate a <code>&lt;TMPL_LOOP&gt;</code>'s contents programmatically.  Here's an example of how this can be done (many other ways are possible!):</p>
<pre>
# a couple of arrays of data to put in a loop:
my @words = qw(I Am Cool);
my @numbers = qw(1 2 3);
	
my @loop_data = ();  # initialize an array to hold your loop
	
while (@words and @numbers) {
    my %row_data;  # get a fresh hash for the row data
	  
    # fill in this row
    $row_data{WORD} = shift @words;
    $row_data{NUMBER} = shift @numbers;

    # the crucial step - push a reference to this row into the loop!
    push(@loop_data, \%row_data);
}
	
# finally, assign the loop data to the loop param, again with a
# reference:
$template-&gt;param(THIS_LOOP =&gt; \@loop_data);
</pre>
<p>The above example would work with a template like:</p>
<pre>
&lt;TMPL_LOOP NAME=&quot;THIS_LOOP&quot;&gt;
    Word: &lt;TMPL_VAR NAME=&quot;WORD&quot;&gt;      &lt;br&gt;
    Number: &lt;TMPL_VAR NAME=&quot;NUMBER&quot;&gt; &lt;p&gt;
&lt;/TMPL_LOOP&gt;
</pre>
<p>It would produce output like:</p>
<pre>
Word: I
Number: 1
	
Word: Am
Number: 2
	
Word: Cool
Number: 3
</pre>
<p><code>&lt;TMPL_LOOP&gt;</code>s within <code>&lt;TMPL_LOOP&gt;</code>s are fine and work as you would
expect.  If the syntax for the <code>param()</code> call has you stumped, here's an
example of a param call with one nested loop:</p>
<pre>
$template-&gt;param(LOOP =&gt; [{ 
    name =&gt; 'Bobby',
    nicknames =&gt; [
        { name =&gt; 'the big bad wolf' }, 
        { name =&gt; 'He-Man' },
    ],
}]);
</pre>
<p>Basically, each <code>&lt;TMPL_LOOP&gt;</code> gets an array reference.  Inside the array are any number of hash references.  These hashes contain the name=&gt;value pairs for a single pass over the loop template.</p>
<p>Inside a <code>&lt;TMPL_LOOP&gt;</code>, the only variables that are usable are the ones from the <code>&lt;TMPL_LOOP&gt;</code>.  The variables in the outer blocks are not visible within a template loop.  For the computer-science geeks among you, a <code>&lt;TMPL_LOOP&gt;</code> introduces a new scope much like a perl subroutine call.  If you want your variables to be global you can use 'global_vars' option to <code>new()</code> described below.</p>

<h3><code>TMPL_INCLUDE</code></h3>
<pre>
&lt;TMPL_INCLUDE NAME=&quot;filename.tmpl&quot;&gt;
</pre>
<p>This tag includes a template directly into the current template at the point where the tag is found.  The included template contents are used exactly as if its contents were physically included in the master template.</p>
<p>The file specified can be an absolute path (beginning with a '/' under Unix, for example).  If it isn't absolute, the path to the enclosing file is tried first.  After that the path in the environment variable <code>HTML_TEMPLATE_ROOT</code> is tried, if it exists.  Next, the <code>path</code> option is consulted, first as-is and then with <code>HTML_TEMPLATE_ROOT</code> prepended if available.  As a final attempt, the filename is passed to <code>open()</code> directly.  See below for more information on <code>HTML_TEMPLATE_ROOT</code> and the <code>path</code> option to <code>new()</code>.</p>
<p>As a protection against infinitly recursive includes, an arbitary limit of 10 levels deep is imposed.  You can alter this limit with the <code>max_includes</code> option.  See the entry for the <code>max_includes</code> option below for more details.</p>

<h3><code>TMPL_IF</code></h3>
<pre>
&lt;TMPL_IF NAME=&quot;PARAMETER_NAME&quot;&gt; &hellip; &lt;/TMPL_IF&gt;
</pre>
<p>The <code>&lt;TMPL_IF&gt;</code> tag allows you to include or not include a block of the template based on the value of a given parameter name.  If the parameter is given a value that is true for Perl &ndash; like '1' &ndash; then the block is included in the output.  If it is not defined, or given a false value &ndash; like '0' &ndash; then it is skipped.  The parameters are specified the same way as with <code>TMPL_VAR</code>.</p>
<p>Example Template:</p>
<pre>
&lt;TMPL_IF NAME=&quot;BOOL&quot;&gt;
    Some text that only gets displayed if BOOL is true!
&lt;/TMPL_IF&gt;
</pre>
<p>Now if you call <code>$template-&gt;param(BOOL =&gt; 1)</code> then the above block will be included by output.</p>
<p><code>&lt;TMPL_IF&gt; &lt;/TMPL_IF&gt;</code> blocks can include any valid HTML::Template construct &ndash; VARs and LOOPs and other IF/ELSE blocks.  Note, however, that intersecting a <code>&lt;TMPL_IF&gt;</code> and a <code>&lt;TMPL_LOOP&gt;</code> is invalid.</p>
<pre>
# Not going to work:
&lt;TMPL_IF BOOL&gt;
    &lt;TMPL_LOOP SOME_LOOP&gt;
&lt;/TMPL_IF&gt;
&lt;/TMPL_LOOP&gt;
</pre>
<p>If the name of a <code>TMPL_LOOP</code> is used in a <code>TMPL_IF</code>, the IF block will output if the loop has at least one row.  Example:</p>
<pre>
&lt;TMPL_IF LOOP_ONE&gt;
    This will output if the loop is not empty.
&lt;/TMPL_IF&gt;

&lt;TMPL_LOOP LOOP_ONE&gt;
    &hellip;.
&lt;/TMPL_LOOP&gt;
</pre>
<div class="note">
    <h4>Warning</h4>
    <p>Much of the benefit of HTML::Template is in decoupling your Perl and HTML.  If you introduce numerous cases where you have <code>TMPL_IF</code>s and matching Perl <code>if()</code>s, you will create a maintenance problem in keeping the two synchronized.  I suggest you adopt the practice of only using TMPL_IF if you can do so without requiring a matching <code>if()</code> in your Perl code.</p>
</div>

<h3><code>TMPL_ELSE</code></h3>
<pre>
&lt;TMPL_IF NAME=&quot;PARAMETER_NAME&quot;&gt; &hellip; &lt;TMPL_ELSE&gt; &hellip; &lt;/TMPL_IF&gt;
</pre>
<p>You can include an alternate block in your <code>TMPL_IF</code> block by using <code>TMPL_ELSE</code>.  NOTE: You still end the block with <code>&lt;/TMPL_IF&gt;</code>, not <code>&lt;/TMPL_ELSE&gt;</code>!</p>
<p>Example:</p>
<pre>
&lt;TMPL_IF BOOL&gt;
    Some text that is included only if BOOL is true
&lt;TMPL_ELSE&gt;
    Some text that is included only if BOOL is false
&lt;/TMPL_IF&gt;
</pre>

<h3><code>TMPL_UNLESS</code></h3>
<pre>
&lt;TMPL_UNLESS NAME=&quot;PARAMETER_NAME&quot;&gt; &hellip; &lt;/TMPL_UNLESS&gt;
</pre>
<p>This tag is the opposite of <code>&lt;TMPL_IF&gt;</code>.  The block is output if the <code>CONTROL_PARAMETER</code> is set false or not defined.  You can use <code>&lt;TMPL_ELSE&gt;</code> with <code>&lt;TMPL_UNLESS&gt;</code> just as you can with <code>&lt;TMPL_IF&gt;</code>.</p>
<p>Example:</p>
<pre>
  &lt;TMPL_UNLESS BOOL&gt;
     Some text that is output only if BOOL is FALSE.
  &lt;TMPL_ELSE&gt;
     Some text that is output only if BOOL is TRUE.
  &lt;/TMPL_UNLESS&gt;
  </pre>
<p>If the name of a <code>TMPL_LOOP</code> is used in a <code>TMPL_UNLESS</code>, the UNLESS block output if the loop has zero rows.</p>
<pre>
&lt;TMPL_UNLESS LOOP_ONE&gt;
    This will output if the loop is empty.
&lt;/TMPL_UNLESS&gt;
  
&lt;TMPL_LOOP LOOP_ONE&gt;
    &hellip;
&lt;/TMPL_LOOP&gt;
</pre>

<div class="note">
    <h4>Note</h4>
	<p>HTML::Template's tags are meant to mimic normal HTML tags.  However, they are allowed to &quot;break the rules&quot;.  Something like:</p>
<pre>
&lt;img src=&quot;&lt;TMPL_VAR IMAGE_SRC&gt;&quot;&gt;
</pre>
	<p>is not really valid HTML, but it is a perfectly valid use and will work as planned.</p>
	<p>The <code>NAME=</code> in the tag is optional, although for extensibility's sake I recommend using it. Example &ndash; <code>&lt;TMPL_LOOP LOOP_NAME&gt;</code> is acceptable.</p>
	<p>If you're a fanatic about valid HTML and would like your templates 	to conform to valid HTML syntax, you may optionally type template tags 	in the form of HTML comments. This may be of use to HTML authors who would like to validate their templates' HTML syntax prior to HTML::Template processing, or who use DTD-savvy editing tools.</p>
<pre>
&lt;!-- TMPL_VAR NAME=PARAM1 --&gt;
</pre>
	<p>In order to realize a dramatic savings in bandwidth, the standard (non-comment) tags will be used throughout this documentation.</p>
</div>

<h2><a id="methods"></a>Methods</h2>
<h3><code>new()</code></h3>
<p>Call <code>new()</code> to create a new Template object:</p>
<pre>
my $template = HTML::Template-&gt;new( 
    filename =&gt; 'file.tmpl', 
    option =&gt; 'value' 
);
</pre>
<p>You must call <code>new()</code> with at least one name =&gt; value pair specifying how
to access the template text.  You can use <code>filename =&gt; 'file.tmpl'</code> 
to specify a filename to be opened as the template.  Alternately you can
use:</p>
<pre>
my $t = HTML::Template-&gt;new( 
    scalarref =&gt; $ref_to_template_text, 
    option =&gt; 'value' 
);
</pre>
<p>and</p>
<pre>
my $t = HTML::Template-&gt;new( 
    arrayref =&gt; $ref_to_array_of_lines , 
    option =&gt; 'value' 
);
</pre>
<p>These initialize the template from in-memory resources.  In almost every case you'll want to use the filename parameter.  If you're worried about all the disk access from reading a template file just use mod_perl and the cache option detailed below.</p>
<p>You can also read the template from an already opened filehandle, either traditionally as a glob or as a FileHandle:</p>
<pre>
my $t = HTML::Template-&gt;new( filehandle =&gt; *FH, option =&gt; 'value');
</pre>
<p>The four <code>new()</code> calling methods can also be accessed as below, if you
prefer.</p>
<pre>
my $t = HTML::Template-&gt;new_file('file.tmpl', option =&gt; 'value');
</pre>
<pre>
my $t = HTML::Template-&gt;new_scalar_ref(
    $ref_to_template_text, 
    option =&gt; 'value'
);
</pre>
<pre>
my $t = HTML::Template-&gt;new_array_ref(
    $ref_to_array_of_lines, 
    option =&gt; 'value'
);
</pre>
<pre>
my $t = HTML::Template-&gt;new_filehandle($fh, option =&gt; 'value');
</pre>
<p>And as a final option, for those that might prefer it, you can call new as:</p>
<pre>
my $t = HTML::Template-&gt;new(
    type =&gt; 'filename', 
    source =&gt; 'file.tmpl'
);
</pre>
<p>Which works for all three of the source types.</p>
<p>If the environment variable <code>HTML_TEMPLATE_ROOT</code> is set and your filename doesn't begin with /, then the path will be relative to the value of <code>$HTML_TEMPLATE_ROOT</code>.  Example &ndash; if the environment variable <code>HTML_TEMPLATE_ROOT</code> is set to <em>/home/sam</em> and I call <code>HTML::Template-&gt;new()</code> with filename set to <em>sam.tmpl</em>, HTML::Template will try to open <em>/home/sam/sam.tmpl</em> to access the template file.  You can also affect the search path for files with the <code>path</code> option to <code>new()</code> - see below for more information.</p>

    <h3>Options</h3>
    <p>You can modify the Template object's behavior with <code>new()</code>.  These options
    are available:</p>

<h4>Error Detection Options</h4>
<dl>
	<dt><code>die_on_bad_params</code></dt>
	<dd>
		<p>if set to 0 the module will let you call <code>$template-&gt;param(param_name =&gt; 'value')</code> even if 'param_name' doesn't exist in the template body. Defaults to 1.</p>
	</dd>

	<dt><code>force_untaint</code></dt>
	<dd>
		<p>if set to 1 the module will not allow you to set  unescaped parameters with tainted values. If set to 2 you will have to untaint all parameters, including ones with the escape attribute. This option makes sure you untaint everything so you don't accidentally introduce e.g. cross-site-scripting (CSS) vulnerabilities. Requires taint mode. Defaults to 0.</p>
	</dd>

	<dt><code>strict</code></dt>
	<dd>
		<p>if set to 0 the module will allow things that look like they might be TMPL_* tags to get by without dieing. Example:</p>
<pre>
&lt;TMPL_HUH NAME=ZUH&gt;
</pre>
		<p>Would normally cause an error, but if you call new with <code>strict =&gt; 0</code>, HTML::Template will ignore it. Defaults to 1.</p>
	</dd>

	<dt><code>vanguard_compatibility_mode</code></dt>
	<dd>
		<p>if set to 1 the module will expect to see <code>&lt;TMPL_VAR&gt;</code>s that look like %NAME% in addition to the standard syntax.  Also sets <code>die_on_bad_params =&gt; 0</code>.  If you're not at Vanguard Media trying to use an old format template don't worry about this one. Defaults to 0.</p>
	</dd>
</dl>

<h4>Caching Options</h4>
<dl>
	<dt><code>cache</code></dt>
	<dd>
		<p>if set to 1 the module will cache in memory the parsed templates based on the filename parameter and modification date of the file.  This only applies to templates opened with the filename parameter specified, not scalarref or arrayref templates.  Caching also looks at the modification times of any files included using <code>&lt;TMPL_INCLUDE&gt;</code> tags, but again, only if the template is opened with filename parameter.</p>
		<p>This is mainly of use in a persistent environment like Apache/mod_perl.  It has absolutely no benefit in a normal CGI environment since the script is unloaded from memory after every request.  For a cache that does work for normal CGIs see the 'shared_cache' option below.</p>
		<p>Note that different <code>new()</code> parameter settings do not cause a cache refresh, only a change in the modification time of the template will trigger a cache refresh.  For most usages this is fine.  My simplistic testing shows that using cache yields a 90% performance increase under mod_perl. Cache defaults to 0.</p>
	</dd>
	
	<dt><code>shared_cache</code></dt>
	<dd>
		<p>if set to 1 the module will store its cache in shared memory using the IPC::SharedCache module (available from CPAN).  The effect of this will be to maintain a single shared copy of each parsed template for all instances of HTML::Template to use.  This can be a significant reduction in memory usage in a multiple server environment.  As an example, on one of our systems we use 4MB of template cache and maintain 25 httpd processes &ndash; shared_cache results in saving almost 100MB!  Of course, some reduction in speed versus
normal caching is to be expected.  Another difference between normal caching and shared_cache is that shared_cache will work in a CGI environment - normal caching is only useful in a persistent environment like Apache/mod_perl.</p> 
		<p>By default HTML::Template uses the IPC key 'TMPL' as a shared root segment (0x4c504d54 in hex), but this can be changed by setting the <code>ipc_key</code> <code>new()</code> parameter to another 4-character or integer key. Other options can be used to affect the shared memory cache correspond to IPC::SharedCache options - ipc_mode, ipc_segment_size and ipc_max_size.  See IPC::SharedCache for a description of how these work - in most cases you shouldn't need to change them from the defaults.</p>
		<p>For more information about the shared memory cache system used by
HTML::Template see IPC::SharedCache.</p>
	</dd>

	<dt><code>double_cache</code></dt>
	<dd>
		<p>if set to 1 the module will use a combination of shared_cache and normal cache mode for the best possible caching.  Of course, it also uses the most memory of all the cache modes.  All the same ipc_* options that work with shared_cache apply to double_cache as well.  By default double_cache is off.</p>
	</dd>
	
	<dt><code>blind_cache</code></dt>
	<dd>
		<p>if set to 1 the module behaves exactly as with normal caching but does not check to see if the file has changed on each request.  This option should be used with caution, but could be of use on high-load servers.  My tests show blind_cache performing only 1 to 2 percent faster than cache under mod_perl.</p>
		<div class="note">
            <h4>Note</h4>
            <p>Combining this option with shared_cache can result in stale templates stuck permanently in shared memory!</p>
        </div>
	</dd>
	
	<dt><code>file_cache</code></dt>
	<dd>
		<p>if set to 1 the module will store its cache in a file using the Storable module.  It uses no additional memory, and my simplistic testing shows that it yields a 50% performance advantage. Like shared_cache, it will work in a CGI environment. Default is 0.</p>
		<p>If you set this option you must set the <code>file_cache_dir</code> option.  See below for details.</p>
        <div class="note">
            <h4>Note</h4>
            <p>Storable using <code>flock()</code> to ensure safe access to cache files. Using file_cache on a system or filesystem (NFS) without <code>flock()</code> support is dangerous.</p>
        </div>
	</dd>
	
	<dt><code>file_cache_dir</code></dt>
	<dd>
		<p>sets the directory where the module will store the cache files if file_cache is enabled.  Your script will need write permissions to this directory.  You'll also need to make sure the sufficient space is available to store the cache files.</p>
	</dd>

	<dt><code>file_cache_dir_mode</code></dt>
	<dd>
		<p>sets the file mode for newly created file_cache directories and subdirectories.  Defaults to 0700 for security but this may be inconvenient if you do not have access to the account running the webserver.</p>
	</dd>

	<dt><code>double_file_cache</code></dt>
<dd>
<p>if set to 1 the module will use a combination of file_cache and normal cache mode for the best possible caching.  The file_cache_* options that work with file_cache apply to double_file_cache as well. By default <code>double_file_cache</code> is 0.</p>
</dd>
</dl>

<h4>Filesystem Options</h4>
<dl>
	<dt><code>path</code></dt>
	<dd>
		<p>you can set this variable with a list of paths to search for files specified with the <code>filename</code> option to <code>new()</code> and for files included with the <code>&lt;TMPL_INCLUDE&gt;</code> tag.  This list is only consulted when the filename is relative.  The <code>HTML_TEMPLATE_ROOT</code> environment variable is always tried first if it exists.  Also, if <code>HTML_TEMPLATE_ROOT</code> is set then an attempt will be made to prepend <code>HTML_TEMPLATE_ROOT</code> onto paths in the path array.  In the case of a <code>&lt;TMPL_INCLUDE&gt;</code> file, the path to the including file is also tried before path is consulted.</p>
		<p>Example:</p>
<pre>
my $template = HTML::Template-&gt;new(
    filename =&gt; 'file.tmpl',
    path =&gt; [ '/path/to/templates', '/alternate/path' ]
);
</pre>
        <div class="note">
            <h4>Note</h4>
            <p>The paths in the path list must be expressed as UNIX paths, separated by the forward-slash character ('/').</p>
        </div>
	</dd>

	<dt><code>search_path_on_include</code></dt>
	<dd>
		<p>if set to a true value the module will search from the top of the array of paths specified by the path option on every <code>&lt;TMPL_INCLUDE&gt;</code> and use the first matching template found.  The normal behavior is to look only in the current directory for a template to include.  Defaults to 0.</p>
	</dd>
</dl>

<h4>Debugging Options</h4>
<dl>

	<dt><code>debug</code></dt>
	<dd>
		<p>if set to 1 the module will write random debugging information to STDERR.  Defaults to 0.</p>
	</dd>
	
	<dt><code>stack_debug</code></dt>
	<dd>
		<p>if set to 1 the module will use Data::Dumper to print out the contents of the parse_stack to STDERR.  Defaults to 0.</p>
	</dd>
	
	<dt><code>cache_debug</code></dt>
	<dd>
		<p>if set to 1 the module will send information on cache loads, hits and misses to STDERR.  Defaults to 0.</p>
	</dd>
	
	<dt><code>shared_cache_debug</code></dt>
	<dd>
		<p>if set to 1 the module will turn on the debug option in IPC::SharedCache &ndash; see IPC::SharedCache for details. Defaults to 0.</p>
	</dd>

	<dt><code>memory_debug</code></dt>
	<dd>
		<p>if set to 1 the module will send information on cache memory usage to STDERR.  Requires the GTop module.  Defaults to 0.</p>
	</dd>
</dl>

<h4>Miscellaneous Options</h4>
<dl>

	<dt><code>associate</code></dt>
	<dd>
		<p>this option allows you to inherit the parameter values from other objects.  The only requirement for the other object is that it have a <code>param()</code> method that works like HTML::Template's <code>param()</code>. A good candidate would be a CGI.pm query object.  Example:</p>
<pre>
my $query = new CGI;
my $template = HTML::Template-&gt;new(
    filename =&gt; 'template.tmpl',
    associate =&gt; $query
);
</pre>
		<p>Now, <code>$template-&gt;output()</code> will act as though</p>
<pre>
$template-&gt;param('FormField', $cgi-&gt;param('FormField'));
</pre>
		<p>had been specified for each key/value pair that would be provided by the <code>$cgi-&gt;param()</code> method.  Parameters you set directly take precedence over associated parameters.</p> 
		<p>You can specify multiple objects to associate by passing an anonymous array to the associate option.  They are searched for parameters in the order they appear:</p>
<pre>
my $template = HTML::Template-&gt;new(
    filename =&gt; 'template.tmpl',
    associate =&gt; [$query, $other_obj]
);
</pre>
		<p>The old <code>associateCGI()</code> call is still supported, but should be considered obsolete.</p>
		<div class="note">
            <h4>Note</h4>
            <p>The parameter names are matched in a case-insensitve manner.  If you have two parameters in a CGI object like 'NAME' and 'Name' one will be chosen randomly by associate.  This behavior can be changed by the following option.</p>
        </div>
	</dd>

	<dt><code>case_sensitive</code></dt>
	<dd>
		<p>setting this option to true causes HTML::Template to treat template variable names case-sensitively.  The following example would only set one parameter without the <code>case_sensitive</code> option:</p>
<pre>
my $template = HTML::Template-&gt;new(
    filename =&gt; 'template.tmpl',
    case_sensitive =&gt; 1
);

$template-&gt;param(
    FieldA =&gt; 'foo',
    fIELDa =&gt; 'bar',
);
</pre>
		<p>This option defaults to off.</p>
		<div class="note">
            <h4>Note</h4>
            <p>With <code>case_sensitive</code> and <code>loop_context_vars</code> the special loop variables are available in lower-case only.</p>
        </div>
	</dd>

	<dt><code>loop_context_vars</code></dt>
	<dd>
		<p>when this parameter is set to true (it is false by default) four loop context variables are made available inside a loop: <code>__first__</code>, <code>__last__</code>, <code>__inner__</code>, <code>__odd__</code>.  They can be used with <code>&lt;TMPL_IF&gt;</code>, <code>&lt;TMPL_UNLESS&gt;</code> and <code>&lt;TMPL_ELSE&gt;</code> to control how a loop is output.</p>
		<p>In addition to the above, a <code>__counter__</code> var is also made available when loop context variables are turned on.</p>
		<p>Example:</p>
<pre>
&lt;TMPL_LOOP NAME=&quot;FOO&quot;&gt;
&lt;TMPL_IF NAME=&quot;__first__&quot;&gt;
    This only outputs on the first pass.
&lt;/TMPL_IF&gt;
</pre>
<pre>
&lt;TMPL_IF NAME=&quot;__odd__&quot;&gt;
    This outputs every other pass, on the odd passes.
&lt;/TMPL_IF&gt;
</pre>
<pre>
&lt;TMPL_UNLESS NAME=&quot;__odd__&quot;&gt;
    This outputs every other pass, on the even passes.
&lt;/TMPL_UNLESS&gt;
</pre>
<pre>
&lt;TMPL_IF NAME=&quot;__inner__&quot;&gt;
    This outputs on passes that are neither first nor last.
&lt;/TMPL_IF&gt;
</pre>
<pre>
This is pass number &lt;TMPL_VAR NAME=&quot;__counter__&quot;&gt;.
</pre>
<pre>
&lt;TMPL_IF NAME=&quot;__last__&quot;&gt;
    This only outputs on the last pass.
&lt;/TMPL_IF&gt;
&lt;/TMPL_LOOP&gt;
</pre>
		<p>One use of this feature is to provide a &quot;separator&quot; similar in effect to the perl function <code>join()</code>.  Example:</p>
<pre>
&lt;TMPL_LOOP FRUIT&gt;
    &lt;TMPL_IF __last__&gt; and &lt;/TMPL_IF&gt;
    &lt;TMPL_VAR KIND&gt;&lt;TMPL_UNLESS __last__&gt;, &lt;TMPL_ELSE&gt;.&lt;/TMPL_UNLESS&gt;
&lt;/TMPL_LOOP&gt;
</pre>
		<p>Would output (in a browser) something like:</p>
<pre>
Apples, Oranges, Brains, Toes, and Kiwi.
</pre>
		<p>Given an appropriate <code>param()</code> call, of course.</p>  
		<div class="note">
            <h4>Note</h4>
            <p>A loop with only a single pass will get both <code>__first__</code> and <code>__last__</code> set to true, but not <code>__inner__</code>.</p>
        </div>
	</dd>
	
	<dt><code>no_includes</code></dt>
	<dd>
		<p>set this option to 1 to disallow the <code>&lt;TMPL_INCLUDE&gt;</code> tag in the template file.  This can be used to make opening untrusted templates <strong>slightly</strong> less dangerous.  Defaults to 0.</p>
	</dd>
	
	<dt><code>max_includes</code></dt>
	<dd>
		<p>set this variable to determine the maximum depth that includes can reach.  Set to 10 by default.  Including files to a depth greater than this value causes an error message to be displayed.  Set to 0 to disable this protection.</p>
	</dd>
	
	<dt><code>global_vars</code></dt>
	<dd>
		<p>normally variables declared outside a loop are not available inside a loop.  This option makes <code>&lt;TMPL_VAR&gt;</code>s like global variables in Perl &ndash; they have unlimited scope.  This option also affects <code>&lt;TMPL_IF&gt;</code> and <code>&lt;TMPL_UNLESS&gt;</code>.</p>
		<p>Example:</p>
<pre>
This is a normal variable: &lt;TMPL_VAR NORMAL&gt;.&lt;P&gt;
</pre>
<pre>
&lt;TMPL_LOOP NAME=FROOT_LOOP&gt;
    Here it is inside the loop: &lt;TMPL_VAR NORMAL&gt;&lt;P&gt;
&lt;/TMPL_LOOP&gt;
</pre>
		<p>Normally this wouldn't work as expected, since <code>&lt;TMPL_VAR NORMAL&gt;</code>'s value outside the loop is not available inside the loop.</p>
		<p>The global_vars option also allows you to access the values of an enclosing loop within an inner loop.  For example, in this loop the inner loop will have access to the value of OUTER_VAR in the correct iteration:</p>
<pre>
&lt;TMPL_LOOP OUTER_LOOP&gt;
    OUTER: &lt;TMPL_VAR OUTER_VAR&gt;
    &lt;TMPL_LOOP INNER_LOOP&gt;
        INNER: &lt;TMPL_VAR INNER_VAR&gt;
        INSIDE OUT: &lt;TMPL_VAR OUTER_VAR&gt;
    &lt;/TMPL_LOOP&gt;
&lt;/TMPL_LOOP&gt;
</pre>
		<p>One side-effect of global-vars is that variables you set with <code>param()</code> that might otherwise be ignored when <code>die_on_bad_params</code> is off will stick around.  This is necessary to allow inner loops to access values set for outer loops that don't directly use the value.</p>
        <div class="note">
            <h4>Note</h4>
            <p><code>global_vars</code> is not <code>global_loops</code> (which does not exist). That means that loops you declare at one scope are not available inside other loops even when <code>global_vars</code> is on.</p>
        </div>
	</dd>
	
	<dt><code>filter</code></dt>
	<dd>
		<p>this option allows you to specify a filter for your template files.  A filter is a subroutine that will be called after HTML::Template reads your template file but before it starts parsing template tags.</p>
		<p>In the most simple usage, you simply assign a code reference to the filter parameter.  This subroutine will recieve a single argument &ndash; a reference to a string containing the template file text.  Here is an example that accepts templates with tags that look like &quot;!!!ZAP_VAR FOO!!!&quot; and transforms them into HTML::Template tags:</p>
<pre>
my $filter = sub {
    my $text_ref = shift;
    $$text_ref =~ s/!!!ZAP_(.*?)!!!/&lt;TMPL_$1&gt;/g;
};
	
# open zap.tmpl using the above filter
my $template = HTML::Template-&gt;new(
    filename =&gt; 'zap.tmpl',
    filter =&gt; $filter
);
</pre>
		<p>More complicated usages are possible.  You can request that your filter receieve the template text as an array of lines rather than as a single scalar.  To do that you need to specify your filter using a
hash-ref.  In this form you specify the filter using the <code>sub</code> key and the desired argument format using the <code>format</code> key.  The available formats are <code>scalar</code> and <code>array</code>.  Using the <code>array</code> format will incur a performance penalty but may be more convenient in some situations.</p>
<pre>
my $template = HTML::Template-&gt;new(
    filename =&gt; 'zap.tmpl',
    filter =&gt; {
	    sub =&gt; $filter,
        format =&gt; 'array'
    }
);
</pre>
	<p>You may also have multiple filters.  This allows simple filters to be combined for more elaborate functionality.  To do this you specify an array of filters.  The filters are applied in the order they are
specified.</p> 
<pre>
my $template = HTML::Template-&gt;new(
    filename =&gt; 'zap.tmpl',
    filter =&gt; [{ 
	    sub =&gt; \&amp;decompress,
        format =&gt; 'scalar' 
    }, 
	{ 
		sub =&gt; \&amp;remove_spaces,
        format =&gt; 'array'
    }]
);
</pre>
		<p>The specified filters will be called for any TMPL_INCLUDEed files just as they are for the main template file.</p>
</dd>

	<dt><code>default_escape</code></dt>
	<dd>
		<p>Set this parameter to &quot;HTML&quot;, &quot;URL&quot; or &quot;JS&quot; and HTML::Template will apply the specified escaping to all variables unless they declare a different escape in the template.</p>
	</dd>
</dl>

<h3><code>param()</code></h3>
<p><code>param()</code> can be called in a number of ways:</p>
<ol>
	<li>
		<p>To return a list of parameters in the template:</p>
<pre>
my @parameter_names = $self-&gt;param();
</pre>
	</li>
	
	<li>
		<p>To return the value set to a param:</p>
<pre>
my $value = $self-&gt;param('PARAM');
</pre>
	</li>
	
	<li>
		<p>To set the value of a parameter:</p>
<pre>
# For simple TMPL_VARs:
$self-&gt;param(PARAM =&gt; 'value');
</pre>
<pre>
# with a subroutine reference that gets called to get the value
# of the scalar.  The sub will recieve the template object as a
# parameter.
$self-&gt;param(PARAM =&gt; sub { return 'value' });
</pre>
<pre>
# And TMPL_LOOPs:
$self-&gt;param(LOOP_PARAM =&gt; [ 
    { PARAM =&gt; VALUE_FOR_FIRST_PASS, &hellip; }, 
    { PARAM =&gt; VALUE_FOR_SECOND_PASS, &hellip; } 
    &hellip;
]);
</pre>
	</li>
	
	<li>
		<p>To set the value of a a number of parameters:</p>
<pre>
# For simple TMPL_VARs:
$self-&gt;param(
    PARAM =&gt; 'value', 
    PARAM2 =&gt; 'value'
);
</pre>
<pre>
# And with some TMPL_LOOPs:
$self-&gt;param(
    PARAM =&gt; 'value', 
    PARAM2 =&gt; 'value',
    LOOP_PARAM =&gt; [ 
        { PARAM =&gt; VALUE_FOR_FIRST_PASS, &hellip; }, 
        { PARAM =&gt; VALUE_FOR_SECOND_PASS, &hellip; } 
        &hellip;
    ],
    ANOTHER_LOOP_PARAM =&gt; [ 
        { PARAM =&gt; VALUE_FOR_FIRST_PASS, &hellip; }, 
        { PARAM =&gt; VALUE_FOR_SECOND_PASS, &hellip; } 
        &hellip;
    ]
);
</pre>
	</li>

	<li>
		<p>To set the value of a a number of parameters using a hash-ref:</p>
<pre>
$self-&gt;param({ 
    PARAM =&gt; 'value', 
    PARAM2 =&gt; 'value',
    LOOP_PARAM =&gt; [ 
        { PARAM =&gt; VALUE_FOR_FIRST_PASS, &hellip; }, 
        { PARAM =&gt; VALUE_FOR_SECOND_PASS, &hellip; } 
        &hellip;
    ],
    ANOTHER_LOOP_PARAM =&gt; [ 
        { PARAM =&gt; VALUE_FOR_FIRST_PASS, &hellip; }, 
        { PARAM =&gt; VALUE_FOR_SECOND_PASS, &hellip; } 
        &hellip;
    ]}
);
</pre>
		<p>An error occurs if you try to set a value that is tainted if the <code>force_untaint</code> option is set.</p>
	</li>
</ol>

<h3><code>clear_params()</code></h3>
<p>Sets all the parameters to undef.  Useful internally, if nowhere else!</p>

<h3><code>output()</code></h3>
<p><code>output()</code> returns the final result of the template.  In most situations you'll want to print this, like:</p>
<pre>
print $template-&gt;output();
</pre>
<p>When output is called each occurrence of <code>&lt;TMPL_VAR NAME=name&gt;</code> is replaced with the value assigned to &quot;name&quot; via <code>param()</code>.  If a named parameter is unset it is simply replaced with ''.  <code>&lt;TMPL_LOOPS&gt;</code> are evaluated once per parameter set, accumlating output on each pass.</p>
<p>Calling <code>output()</code> is guaranteed not to change the state of the Template object, in case you were wondering.  This property is mostly important for the internal implementation of loops.</p>
<p>You may optionally supply a filehandle to print to automatically as the template is generated.  This may improve performance and lower memory consumption.  Example:</p>
<pre>
$template-&gt;output(print_to =&gt; *STDOUT);
</pre>
<p>The return value is undefined when using the <code>print_to</code> option.</p>

<h3><code>query()</code></h3>
<p>This method allow you to get information about the template structure. It can be called in a number of ways.  The simplest usage of query is simply to check whether a parameter name exists in the template, using the <code>name</code> option:</p>
<pre>
if ($template-&gt;query(name =&gt; 'foo')) {
    # do something if a varaible of any type 
    # named FOO is in the template
}
</pre>
<p>This same usage returns the type of the parameter.  The type is the same as the tag minus the leading 'TMPL_'.  So, for example, a <code>TMPL_VAR</code> parameter returns 'VAR' from <code>query()</code>.</p>
<pre>
if ($template-&gt;query(name =&gt; 'foo') eq 'VAR') {
    # do something if FOO exists and is a TMPL_VAR
}
</pre>
<p>Note that the variables associated with TMPL_IFs and TMPL_UNLESSs will be identified as 'VAR' unless they are also used in a TMPL_LOOP, in which case they will return 'LOOP'.</p>
<p><code>query()</code> also allows you to get a list of parameters inside a loop (and inside loops inside loops).  Example loop:</p>
<pre>
&lt;TMPL_LOOP NAME=&quot;EXAMPLE_LOOP&quot;&gt;
    &lt;TMPL_VAR NAME=&quot;BEE&quot;&gt;
    &lt;TMPL_VAR NAME=&quot;BOP&quot;&gt;
    &lt;TMPL_LOOP NAME=&quot;EXAMPLE_INNER_LOOP&quot;&gt;
        &lt;TMPL_VAR NAME=&quot;INNER_BEE&quot;&gt;
        &lt;TMPL_VAR NAME=&quot;INNER_BOP&quot;&gt;
    &lt;/TMPL_LOOP&gt;
&lt;/TMPL_LOOP&gt;
</pre>
<p>And some query calls:</p>
<pre>
# returns 'LOOP'
$type = $template-&gt;query(name =&gt; 'EXAMPLE_LOOP');
</pre>
<pre>
# returns ('bop', 'bee', 'example_inner_loop')
@param_names = $template-&gt;query(loop =&gt; 'EXAMPLE_LOOP');
</pre>
<pre>
# both return 'VAR'
$type = $template-&gt;query(name =&gt; ['EXAMPLE_LOOP', 'BEE']);
$type = $template-&gt;query(name =&gt; ['EXAMPLE_LOOP', 'BOP']);
</pre>
<pre>
# and this one returns 'LOOP'
$type = $template-&gt;query(
    name =&gt; ['EXAMPLE_LOOP', 'EXAMPLE_INNER_LOOP']
);
  
# and finally, this returns ('inner_bee', 'inner_bop')
@inner_param_names = $template-&gt;query(
    loop =&gt; ['EXAMPLE_LOOP', 'EXAMPLE_INNER_LOOP']
);
</pre>
<pre>
# for non existent parameter names you get undef
# this returns undef.
$type = $template-&gt;query(name =&gt; 'DWEAZLE_ZAPPA');
</pre>
<pre>
# calling loop on a non-loop parameter name will cause an error.
# this dies:
$type = $template-&gt;query(loop =&gt; 'DWEAZLE_ZAPPA');
</pre>
<p>As you can see above the <code>loop</code> option returns a list of parameter names and both <code>name</code> and <code>loop</code> take array refs in order to refer to parameters inside loops.  It is an error to use <code>loop</code> with a parameter that is not a loop.</p>
<p>Note that all the names are returned in lowercase and the types are uppercase.</p>
<p>Just like <code>param()</code>, <code>query()</code> with no arguments returns all the parameter names in the template at the top level.</p>

<h2>Frequently Asked Questions</h2>
<p>In the interest of greater understanding I've started a FAQ section of the perldocs.  Please look in here before you send me email.</p>
<ol>
<li>
<p>Q: Is there a place to go to discuss HTML::Template and/or get help?</p>
<p>A: There's a mailing-list for discussing HTML::Template at <a href="mailto:html-template-users@lists.sourceforge.net.">html-template-users@lists.sourceforge.net.</a>  To join:</p>
<pre>
    <a href="http://lists.sourceforge.net/lists/listinfo/html-template-users">http://lists.sourceforge.net/lists/listinfo/html-template-users</a></pre>
<p>If you just want to get email when new releases are available you can join the announcements mailing-list here: <a href="http://lists.sourceforge.net/lists/listinfo/html-template-announce">http://lists.sourceforge.net/lists/listinfo/html-template-announce</a>
</p>
<p>Q: Is there a searchable archive for the mailing-list?</p>
<p>A: Yes, you can find an archive of the SourceForge list here: <a href="http://www.geocrawler.com/lists/3/SourceForge/23294/0/">http://www.geocrawler.com/lists/3/SourceForge/23294/0/</a></p>
<p>For an archive of the old vm.com list, setup by Sean P. Scanlon, see: <a href="http://bluedot.net/mail/archive/">http://bluedot.net/mail/archive/</a></p>
</li>
<li>
<p>Q: I want support for &lt;TMPL_XXX&gt;!  How about it?</p>
<p>A: Maybe.  I definitely encourage people to discuss their ideas for
HTML::Template on the mailing list.  Please be ready to explain to me
how the new tag fits in with HTML::Template's mission to provide a
fast, lightweight system for using HTML templates.</p>
<p>NOTE: Offering to program said addition and provide it in the form of
a patch to the most recent version of HTML::Template will definitely
have a softening effect on potential opponents!</p>
</li>
<li>
<p>Q: I found a bug, can you fix it?</p>
<p>A: That depends.  Did you send me the VERSION of HTML::Template, a test
script and a test template?  If so, then almost certainly.</p>
<p>If you're feeling really adventurous, HTML::Template has a publically
available Subversion server.  See below for more information in the Public
Subversion Server section.</p>
</li>
<li>
<p>Q: &lt;TMPL_VAR&gt;s from the main template aren't working inside a
&lt;TMPL_LOOP&gt;!  Why?</p>
<p>A: This is the intended behavior.  &lt;TMPL_LOOP&gt; introduces a separate
scope for &lt;TMPL_VAR&gt;s much like a subroutine call in Perl introduces a
separate scope for &quot;my&quot; variables.</p>
<p>If you want your &lt;TMPL_VAR&gt;s to be global you can set the
'global_vars' option when you call <code>new()</code>.  See above for documentation
of the 'global_vars' <code>new()</code> option.</p>
</li>
<li>
<p>Q: Why do you use /[Tt]/ instead of /t/i?  It's so ugly!</p>
<p>A: Simple - the case-insensitive match switch is very inefficient.
According to _Mastering_Regular_Expressions_ from O'Reilly Press,
/[Tt]/ is faster and more space efficient than /t/i - by as much as
double against long strings.  //i essentially does a <code>lc()</code> on the
string and keeps a temporary copy in memory.</p>
<p>When this changes, and it is in the 5.6 development series, I will
gladly use //i.  Believe me, I realize [Tt] is hideously ugly.</p>
</li>
<li>
<p>Q: How can I pre-load my templates using cache-mode and mod_perl?</p>
<p>A: Add something like this to your startup.pl:</p>
<pre>
use HTML::Template;
use File::Find;
</pre>
<pre>
print STDERR &quot;Pre-loading HTML Templates&hellip;\n&quot;;
find(
    sub {
        return unless /\.tmpl$/;
        HTML::Template-&gt;new(
            filename =&gt; &quot;$File::Find::dir/$_&quot;,
            cache =&gt; 1,
        );
    },
    '/path/to/templates',
    '/another/path/to/templates/'
);
</pre>
<p>Note that you'll need to modify the &quot;return unless&quot; line to specify
the extension you use for your template files - I use .tmpl, as you
can see.  You'll also need to specify the path to your template files.</p>
<p>One potential problem: the &quot;/path/to/templates/&quot; must be EXACTLY the
same path you use when you call HTML::Template-&gt;<code>new()</code>.  Otherwise the
cache won't know they're the same file and will load a new copy -
instead getting a speed increase, you'll double your memory usage.  To
find out if this is happening set cache_debug =&gt; 1 in your application
code and look for &quot;CACHE MISS&quot; messages in the logs.</p>
</li>
<li>
<p>Q: What characters are allowed in TMPL_* NAMEs?</p>
<p>A: Numbers, letters, '.', '/', '+', '-' and '_'.</p>
</li>
<li>
<p>Q: How can I execute a program from inside my template?</p>
<p>A: Short answer: you can't.  Longer answer: you shouldn't since this
violates the fundamental concept behind HTML::Template - that design
and code should be seperate.</p>
<p>But, inevitably some people still want to do it.  If that describes
you then you should take a look at
<em>HTML::Template::Expr</em>.  Using
HTML::Template::Expr it should be easy to write a <code>run_program()</code>
function.  Then you can do awful stuff like:</p>
<pre>
&lt;tmpl_var expr=&quot;run_program('foo.pl')&quot;&gt;
</pre>
<p>Just, please, don't tell me about it.  I'm feeling guilty enough just
for writing HTML::Template::Expr in the first place.</p>
</li>
<li>
<p>Q: Can I get a copy of these docs in Japanese?</p>
<p>A: Yes you can.  See Kawai Takanori's translation at: <a href="http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm">http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm</a></p>
</li>
<li>
<p>Q: What's the best way to create a &lt;select&gt; form element using
HTML::Template?</p>
<p>A: There is much disagreement on this issue.  My personal preference
is to use CGI.pm's excellent <code>popup_menu()</code> and <code>scrolling_list()</code>
functions to fill in a single &lt;tmpl_var select_foo&gt; variable.</p>
<p>To some people this smacks of mixing HTML and code in a way that they
hoped HTML::Template would help them avoid.  To them I'd say that HTML
is a violation of the principle of separating design from programming.
There's no clear separation between the programmatic elements of the
&lt;form&gt; tags and the layout of the &lt;form&gt; tags.  You'll have to draw
the line somewhere - clearly the designer can't be entirely in charge
of form creation.</p>
<p>It's a balancing act and you have to weigh the pros and cons on each side.
It is certainly possible to produce a &lt;select&gt; element entirely inside the
template.  What you end up with is a rat's nest of loops and conditionals.
Alternately you can give up a certain amount of flexibility in return for
vastly simplifying your templates.  I generally choose the latter.</p>
<p>Another option is to investigate HTML::FillInForm which some have
reported success using to solve this problem.</p>
</li>
</ol>

<h2>Bugs</h2>
<p>I am aware of no bugs &ndash; if you find one, join the mailing list and tell us about it.  You can join the HTML::Template mailing-list by visiting: <a href="http://lists.sourceforge.net/lists/listinfo/html-template-users">http://lists.sourceforge.net/lists/listinfo/html-template-users</a></p>
<p>Of course, you can still email me directly (<a href="mailto:sam@tregar.com">sam@tregar.com</a>) with bugs, but I reserve the right to forward bug reports to the mailing list.</p>
<p>When submitting bug reports, be sure to include full details, including the VERSION of the module, a test script and a test template demonstrating the problem!</p>
<p>If you're feeling really adventurous, HTML::Template has a publically available Subversion server.  
See below for more information in the PUBLIC SUBVERSION SERVER section.</p>

<h2><a id="author"></a>Credits</h2>
<p>This module was the brain child of my boss, Jesse Erlbaum &lt;mailto:jesse@vm.com"&gt;jesse@vm.com&gt; at  <a href="http://vm.com">Vanguard Media</a>.  The most original idea in this module &ndash; the &lt;TMPL_LOOP&gt; - was entirely his.</p>
<p>Fixes, Bug Reports, Optimizations and Ideas have been generously provided by:</p>
<ul>
    <li>Richard Chen</li>
    <li>Mike Blazer</li>
    <li>Adriano Nagelschmidt Rodrigues</li>
    <li>Andrej Mikus</li>
    <li>Ilya Obshadko</li>
    <li>Kevin Puetz</li>
    <li>Steve Reppucci</li>
    <li>Richard Dice</li>
    <li>Tom Hukins</li>
    <li>Eric Zylberstejn</li>
    <li>David Glasser</li>
    <li>Peter Marelas</li>
    <li>James William Carlson</li>
    <li>Frank D. Cringle</li>
    <li>Winfried Koenig</li>
    <li>Matthew Wickline</li>
    <li>Doug Steinwand</li>
    <li>Drew Taylor</li>
    <li>Tobias Brox</li>
    <li>Michael Lloyd</li>
    <li>Simran Gambhir</li>
    <li>Chris Houser &lt;chouser@bluweb.com&gt;</li>
    <li>Larry Moore</li>
    <li>Todd Larason</li>
    <li>Jody Biggs</li>
    <li>T.J. Mather</li>
    <li>Martin Schroth</li>
    <li>Dave Wolfe</li>
    <li>uchum</li>
    <li>Kawai Takanori</li>
    <li>Peter Guelich</li>
    <li>Chris Nokleberg</li>
    <li>Ralph Corderoy</li>
    <li>William Ward</li>
    <li>Ade Olonoh</li>
    <li>Mark Stosberg</li>
    <li>Lance Thomas</li>
    <li>Roland Giersig</li>
    <li>Jere Julian</li>
    <li>Peter Leonard</li>
    <li>Kenny Smith</li>
    <li>Sean P. Scanlon</li>
    <li>Martin Pfeffer</li>
    <li>David Ferrance</li>
    <li>Gyepi Sam</li>
    <li>Darren Chamberlain</li>
    <li>Paul Baker</li>
    <li>Gabor Szabo</li>
    <li>Craig Manley</li>
    <li>Richard Fein</li>
    <li>The Phalanx Project</li>
    <li>Sven Neuhaus</li>
</ul>
<p>Thanks!</p>

<h2><a id="versions"></a>Change History</h2>

<h4>2.91 Fri Mar 30 2012</h4>
<ul>
   	<li>Feature: RT #18901 - Added new utf8 option to make it really simple to use UTF-8 encoded templates [Michael Peters]</li>
   	<li>Feature: RT #30586 - Added new open_mode option to allow for Perl IO layers to interact when using open() on the template files [moritz@faui2k3.org and Michael Peters]</li>
   	<li>Feature: RT #38189 - Allow clean XML style tags "&lt;tmpl_var foo /&gt;" to be used as well. [allard@byte.nl]</li>
   	<li>Feature: RT #46285 - Added support for lazily-evaluated coderefs for TMPL_LOOPs. [Justin DeVuyst and Michael Peters]</li>
   	<li>Feature: RT #64797 - Added new option die_on_missing_include (defaults to true) that allows users to turn off the behavior of dieing when an include can't be found [Zdenek Styblik and Michael Peters]</li>
   	<li>Feature: Add new cache_lazy_vars option so that the values from coderefs used for TMPL_VARs can be cached and the coderef not run multiple times [Michael Peters]</li>
   	<li>Feature: Add new cache_lazy_loops option so that the values from coderefs used for TMPL_LOOPs can be cached and the coderef not run multiple times [Michael Peters]</li>
   	<li>Feature: Added __even__, __outer__ and __index__ loop context vars. [Michael Peters]</li>
   	<li>Bug Fix: RT #26456 - force_untaint can't work in Perl &lt; 5.8.0 [admin@photoresearchers.com]</li>
   	<li>Bug Fix: RT #67663 - remove warning under Perl &gt; 5.14.0 about using tied with a file handle without "*" [RENEEB, TODDR and Michael Peters]</li>
   	<li>Bug Fix: RT #35534 - Using the same loop multiple times with different vars will no longer cause an error if die_on_bad_params is set. [Ron Savage and Michael Peters]</li>
   	<li>Bug Fix: RT #38325 - Give a better error message if param() is set with a reference to a reference. [Mark Stosberg and Michael Peters]</li>
   	<li>Test Fix: RT #26103 - t/05-blind-cache.t no longer modifies the distribution during the tests but instead uses temp files [Jan Dubois and Michael Peters]</li>
   	<li>Test Fix: Tests that create and modify files now use temp files and file_cache_dir is always a temp directory [Michael Peters]</li>
   	<li>Doc Fix: Using more POD formatting [Michael Peters]</li>
   	<li>Doc Fix: RT #46244 - fix broken link to tutorial [Michael Peters]</li>
   	<li>Doc Fix: RT #60282 - fix various mispellings [Florian Ernst]</li>
   	<li>Doc Fix: RT #60283 - fix broken HTML example [Florian Ernst]</li>
   	<li>Doc Fix: RT #60284 - fix broken POD [Florian Ernst and Michael Peters]</li>
   	<li>Development: Moved development to GitHub (https://github.com/mpeters/html-template)</li>
   	<li>Development: Switched to using Dist::Zilla internally for release management</li>
   	<li>Development: Added Michael Peters as co-maintainer</li>
</ul>

<h4>2.9 Mon Jan 29 15:54:03 EST 2007</h4>
<ul>
	<li>New Feature: the new force_untaint option makes sure you do not pass tainted values to param(). [Sven Neuhaus]</li>
	<li>New Feature: Added ESCAPE=NONE as a synonym for ESCAPE=0.  Fixed both to work with default_escape. [cpan@punch.net]</li>
	<li>Bug Fix: DEFAULT didn't work with URL and JS escaping.</li>
	<li>Bug Fix: Long-standing bug where variables set in a loop weren't available inside inner loops under global_vars if the variable wasn't actually used in the outer loop.  (Thanks to Richard Fein for help debugging the fix.)</li>
	<li>Doc Fix: Changed references to CVS in the docs to Subversion now that he switch is complete.</li>
	<li>Test Fix: At long last, the work from the Phalanx project has been merged!  The tests are now more complete and easier to work on.  Thanks Phalanx guys!</li>
</ul>

<h4>2.8 Wed Dec 21 18:37:39 EST 2005</h4>
<ul>
	<li>New Feature: the new default_escape option allows you to apply escaping to all variables in a template. [Alex Kapranoff]</li>
	<li>Bug Fix: ESCAPE wasn't working on variables containing code-refs.</li>
	<li>Bug Fix: Changed HTML::Template to help sub-classes by called _new_from_loop() via ref($self) rather than hard-coding the package name. [Mark Stosberg]</li>
	<li>Bug Fix: Including more than one &lt;tmpl_else&gt; tag in &lt;tmpl_unless&gt; or &lt;tmpl_unless&gt; now dies with an error message, instead of silently ignoring one of the clauses. [Mitar and Mark Stosberg]</li>
	<li>Bug Fix: Fixed HTML::Template to re-evaluate conditions to handle &lt;tmpl_else&gt;.  This bug could cause HTML::Template to take both branches of a conditional if a code-ref parameter returned a different value when called a second time. [Emanuele Zeppieri]</li>
</ul>


<h4>2.7 Thu Jun 24 12:00:00 2004</h4>
<ul>
	<li>New Feature: Added javascript escaping with ESCAPE=JS. (Craig Manley)</li>
	<li>Bug Fix: Improved cache keying to be sensitive to options which alter the compilation of templates (path, search_path, loop_context_vars and global_vars).  Calls to new() with different settings for any of these options will no longer pull incorrect cached objects.</li>
	<li>Bug Fix: Added code to detect broken Perl 5.8.0 installs during installation (i.e. Redhat 8 and 9).</li>
	<li>Bug Fix: Fixed parsing of ESCAPE='URL' (Paul Baker)</li>
	<li>Bug Fix: Added check for empty filename passed to new().</li>
	<li>Test Fix: Migrated tests to Test::More.  This will allow the easier introduction of new tests and the use of Devel::Cover. (Gabor Szabo)</li>
</ul>

<h4>2.6 Thu Aug 29 12:00:00 2002</h4>
<ul>
	<li>New Feature: HTML::Template will combine HTML_TEMPLATE_ROOT environment variable and path option if both are available. (Jesse Erlbaum)</li>
	<li>New Feature: __counter__ variable now available when loop_context_vars is set (Simran Gambhir)</li>
	<li>New Feature: The default attribute allows you to specify defaults for &lt;tmpl_var&gt; tags.</li>
	<li>Bug Fix: fixed parser to reject &lt;tmpl_var&gt;s with no names. (crazyinsomniac)</li>
	<li>Doc Fix: fixed documentation to correctly describe the interaction of case_sensitive and loop_context_vars. (Peter Claus Lamprecht)</li>
	<li>Doc Fix: updated mailing-list information to reflect move from vm.com to sourceforge.net</li>
</ul>

<h4>2.5 Fri Feb 01 12:00:00 2002</h4>
<ul>
	<li>Bug Fix: global_vars fixed for loops within loops</li>
	<li>Bug Fix: include paths were broken under Windows (David Ferrance)</li>
	<li>Bug Fix: nested include path handling was wrong (Gyepi Sam)</li>
	<li>Bug Fix: MD5 signatures for file cache corrected (Martin Schroth)</li>
	<li>Bug Fix: print_to was broken for tied filehandles (Darren Chamberlain)</li>
	<li>Doc Fix: added mailing-list archive URL to FAQ, added link to tutorial, fixed typos and formatting</li>
	<li>Doc Fix: added reference to new HTML::Template website at http://html-template.sourceforge.net/</li>
</ul>

<h4>2.4 Mon August 27 12:00:00 2001</h4>
<ul>
	<li>Bug Fix: case_sensitive option broke loops (Peter Leonard)</li>
	<li>Bug Fix: code-ref params now work with IF and UNLESS</li>
</ul>

<h4>2.3 Thu June 28 12:00:00 2001</h4>
<ul>
	<li>New Feature: template tags can now span lines.  (Roland Giersig)</li>
	<li>New Feature: new() option 'filehandle'. (Roland Giersig)</li>
	<li>Bug Fix: includes were broken in some cases using scalarref templates. (Lance Thomas)</li>
	<li>Bug Fix: recursive include detection was broken for scalarref templates. (Mark Stosberg)</li>
	<li>Bug Fix: cleaned up more 5.004 warnings. (Jere Julian)</li>
</ul>
   
<h4>2.2 Sat December 23 12:00:00 2000</h4>
<ul>
	<li>Bug Fix: fixed memory leak in global_vars implementation (Ade Olonoh)</li>
	<li>Bug Fix: fixed file_cache not reloading templates on changes (T.J. Mather)</li>
	<li>Bug Fix: fixed broken error checking in param() (Mark Stosberg)</li>
</ul>

<h4>2.1 Sun December 18 12:00:00 2000</h4>
<ul>
	<li>New Feature: new 'file_cache' and 'double_file_cache' options provide a file based caching method (T.J. Mather)</li>
	<li>New Feature: new 'print_to' option for output() allows output() to print to a filehandle as it runs. (Chris Nokleberg)</li>
	<li>New Feature: new 'case_sensitive' option to allow template variable names to be case sensitive. (Matthew Wickline)</li>
	<li>New Feature: new 'filter' option allows pre-parse filtering of template files.</li>
	<li>Bug Fix: added single-quote escaping to HTML escaping code (Ralph Corderoy)</li>
	<li>Bug Fix: fixed a noisy bug in param() when used with 'associate' (William Ward)</li>
	<li>Doc Fix: broke out FAQ into separate file.</li>
</ul>

<h4>2.0 Sun September 16 12:00:00 2000 </h4>
<ul>
	<li>New Feature: new 'search_path_on_include' option (Jody Biggs)</li>
	<li>New Feature: much requested variable __ODD__ added to set of loop_context_vars.</li>
	<li>New Feature: new 'no_includes' option (Scott Guelich)</li>
	<li>Doc Addition: Added link to Japanese translation (Kawai Takanori)</li>
	<li>Bug Fix: loop_context_vars was mostly broken (T.J. Mather, Martin Schroth and Dave Wolfe)</li>
	<li>Bug Fix: vanguard_compatibility_mode was broken on first line of included files. (uchum)</li>
</ul>

<h4>1.8 Sun June 25 12:00:00 2000</h4>
<ul>
	<li>New Feature: global_vars option makes outer variables visible inside loops.</li>
	<li>Bug Fix: Use File::Spec to construct pathnames.  This means that HTML::Template should now work on VMS and MacOS. (Larry Moore)</li>
	<li>Bug Fix: loop_context_vars were broken in an unusual case (Todd Larason)</li>
	<li>Bug Fix: ESCAPE was broken in some cases.</li>
	<li>New License: switched to GPL/Artistic hybrid normally used with Perl modules.</li>
</ul>

<h4>1.7 Fri March 24 12:00:00 2000</h4>
<ul>
	<li>New Feature: new method query() enables introspection into loops (Chris Houser)</li>
	<li>New Feature: Better error handling with Carp</li>
	<li>Bug Fix: URLESCAPE was skipping some important escapes (Simran Gambhir)</li>
	<li>New FAQ: How can I execute a program from inside my template?</li>
</ul>

<h4>1.6 Sun March 05 12:00:00 2000</h4>
<ul>
	<li>New Feature: double_cache combines shared memory and local memory caching for twice the speedup!</li>
	<li>New feature: ESCAPE=URL (added by Tobias Brox)</li>
	<li>Bug Fix: allow for blessed objects in calls to param() (thanks to Michael Lloyd and David Glasser)</li>
	<li>Bug Fix: _mtime was broken in 1.5, fixed a typo.</li>
</ul>

<h4>1.5.1 Wed February 23 12:00:00 2000</h4>
<ul>
	<li>Bug Fix: 1.5 broke caching in some cases - thanks to Drew Taylor for help solving this one.</li>
</ul>

<h4>1.5 Mon February 17 12:00:00 2000</h4>
<ul>
	<li>Shared cache now uses IPC::SharedCache and is much more stable.</li>
	<li>Fixed problem with mixed case associated CGI.pm parameters</li>
	<li>param() now accepts subroutine refs for TMPL_VARs.</li>
</ul>       

<h4>1.4 Sat January 8 12:00:00 2000</h4>
<ul>
	<li>New feature: new() option 'shared_cache' enables experimental IPC shared memory caching!</li>
	<li>TMPL_IF now works on TMPL_LOOP variables.</li>
	<li>Public CVS server available at www.sourceforge.net.</li>
	<li>Bug Fix from Doug Steinwand: loop_context_vars not working on one-item loops.</li>
</ul>

<h4>1.3 Fri December 17 12:00:00 1999 </h4>
<ul>
	<li>Omnibus regex patch from Matthew Wickline: a faster and more robust parse().</li>
	<li>New tag: TMPL_UNLESS, the opposite of TMPL_IF.</li>
	<li>Numerous bug fixes: mixed-case filenames in includes, recursive TMPL_INCLUDEs, reporting filename and line number inside included files, better syntax-error detection.</li>
	<li>Optional loop context variables - __FIRST__, __LAST__ and __INNER__.</li>
</ul>

<h4>1.2.1 Wed November 17 12:00:01 1999</h4>
<ul>
	<li>tiny bug fix</li>
</ul>

<h4>1.2 Wed November 17 12:00:00 1999</h4>
<ul>
	<li>Added multi-parameter and hash-ref syntax for param() calls.</li>
	<li>Added DTD-compliant &lt;!-- TMPL_* --&gt; syntax patch from Matthew Wickline - Thanks!</li>
	<li>vanguard_compatibility_mode = 1 implies die_on_bad_params = 0</li>
</ul>

<h4>1.1 Fri November 05 12:00:00 1999</h4>
<ul>
	<li>Lifted requirement that &lt;TMPL_INCLUDE&gt;s be alone on a line</li>
	<li>Added "path" option to new() to manipulate search path for templates.</li>
	<li>bug fixes</li>
</ul>      

<h4>1.0 Fri October 28 12:00:00 1999</h4>
<ul>
	<li>An HTML::Template mailing-list!  Send a blank message to htmltmpl-subscribe@lists.vm.com to join.</li>
	<li>bug fixes</li>
	<li>improved docs</li>
</ul>

<h4>0.96  October 14th 1999 15:49</h4>
<ul>
	<li>Added "ESCAPE=1" option to &lt;TMPL_VAR&gt; to HTML-escape variable values.  (Peter Marelas, thanks!)</li>
	<li>more bug fixes (David Glasses, James William Carlson - thanks)</li>
	<li>even *more* code cleanup!</li>
	<li>new FAQ concerning pre-loading templates and mod_perl.</li>
</ul>

<h4>0.95  October 8th 1999 12:28 </h4>
<ul>
	<li>bug fix: some lines were getting chomped (Eric Zylberstejn)</li>
	<li>*NUMEROUS* bug fixes (David Glasser - Thanks a lot!)</li>
	<li>new FAQ section in documentation</li>
	<li>code cleanup and improved comments</li>
</ul>

<h4>0.91  September 29th 1999 17:59 </h4>
<ul>
	<li>bug fix: possible loss of text after a (Thanks to Tom Huskins for alerting me to this one!)</li>
</ul>

<h4>0.9  September 28th 1999 17:46</h4>
<ul>
	<li>&lt;TMPL_IF&gt; and &lt;TMPL_ELSE&gt;</li>
	<li>near total rewrite - faster, smaller, more "compiler-esque" code.</li>
	<li>*MASSIVE* speedups in all modes - up to 10x faster!1</li>
	<li>bug fix : param() wasn't returning names of LOOPs</li>
	<li>This really is version 0.9 so 1.0 is coming up.  Get those bug reports in!</li>
</ul>
<h4>0.06  September 19th 1999 23:09</h4>
<ul>
	<li>added associate parameter to new() and obsoleted associate_CGI() (still supported for now)</li>
	<li>added support for HTML_TEMPLATE_ROOT environment variable</li>
	<li>small performance improvements using typeglobs</li>
	<li>added a performance testing script: time_trial.pl</li>
</ul>
     
<h4>0.051  September 10th 1999 17:30</h4>
<ul>
	<li>small problem with make test fixed.</li>
</ul>

<h4>0.05  September 10th 1999 17:18</h4>
<ul>
	<li>Added &lt;TMPL_INCLUDE&gt; functionality!</li>
	<li>Added associate_CGI() method - donated by Richard Dice</li>
	<li>Cleaned up internal access to new() options.</li>
	<li>more bug fixes from such notables as Kevin Puetz, and Steve Reppucci.</li>
</ul>    

<h4>0.04  Fri June 18 12:00:00 1999</h4>
<ul>
	<li>fixed cacheing - under certain conditions it was totally broken!</li>
	<li>changed {param} to {param_values} - some older perls complained.</li>
	<li>die_on_bad_params =&gt; 0 now also applied to loop body.</li>
	<li>added copious comments about how bad m//i is to avoid future bug reports about [tT][hH][iI][sS]!</li>
	<li>added numerous bug fixes and optimizations submitted by Mike Blazer, Adriano Nagelschmidt Rodrigues, Andrej Mikus and  Ilya Obshadko.  Thanks!</li>
</ul>
     
<h4>0.03  Fri June 11 17:37:00 1999</h4>
<ul>
	<li>fixed a few irritating "undefined variable" errors in -w</li>
	<li>big speedup on large TMPL_LOOPs.  They are at least one order of magnitude faster now!</li>
	<li>die_on_bad_params =&gt; 0 never really worked!  It does now.</li>
</ul>

<h4>0.02  Mon May 31 12:47:00 1999</h4>
<ul>
	<li>die on multiple source parameters in new()</li>
	<li>tries to preserve newlines in loop body</li>
	<li>copies in array contents from array refs on param call i.e. allows for reuse of scratch arrays on calling side</li>
	<li>Added a CREDITS section to the docs, inaugurated it with Richard Chen for his many fixes.</li>
	<li>Added type =&gt; 'sometype', source =&gt; 'source' new() syntax.</li>
	<li>made "NAME=" in tags optional.  Added a test.pl to check for this.</li>
</ul>

<h4>0.01  Mon May 17 15:17:00 1999</h4>
<ul>
	<li>added cacheing to module and perldoc</li>
    <li>moved .tmpl files used by 'make test' to /templates</li>
    <li>first release!</li>
</ul>

<h4>0.00  Fri May 14 14:59:06 1999</h4>
<ul>
	<li>original version; created by h2xs 1.18</li>
</ul>

<h2>Website</h2>
<p>You can find information about HTML::Template and other related modules at: <a href="http://html-template.sourceforge.net">http://html-template.sourceforge.net</a>
</p>

<h2>Author</h2>
<p>Sam Tregar, &lt;sam@tregar.com&gt;</p>

<h2>License</h2>
<p>HTML::Template : A module for using HTML Templates with Perl   Copyright (&copy;) 2000-2002 Sam Tregar &lt;sam@tregar.com"&gt; </p>
<p>This module is free software; you can redistribute it and/or modify it   under the terms of either: </p>
<ol>
    <li>the GNU General Public License as published by the Free Software   Foundation; either version 1, or (at your option) any later version, or</li>
    <li>the &quot;Artistic License&quot; which comes with this module.</li>
   </ol>
<p>This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either   the GNU General Public License or the Artistic License for more details. </p>
<p>You should have received a copy of the Artistic License with this   module, in the file ARTISTIC.  If not, I'll be glad to provide one. </p>
<p>You should have received a copy of the GNU General Public License   along with this program; if not, write to the Free Software   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307   USA </p>
</body>
</html>